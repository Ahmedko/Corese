<?xml version='1.0' encoding='UTF-8'?>
<!--
SPARQL Template Transformation
Olivier Corby - Wimmics - Inria UNS CNRS I3S
Mon Aug 17 10:46:01 CEST 2015
-->
<rdf:RDF  xmlns:rdf='http://www.w3.org/1999/02/22-rdf-syntax-ns#' 
  xmlns='http://ns.inria.fr/edelweiss/2011/rule#'>
<rule>
<body>
<![CDATA[

template  st:statement  {

  xt:nl(st:apply-templates-with-all(st:owlstatement, ?t), 2)
  ; separator = ""
  
}
where {

  {select distinct ?t where {
     ?t ?p ?y 
     
     filter (?p not in 
     (rdfs:subClassOf, owl:equivalentClass)
     )
     
    filter (
      (isURI(?t)   && not exists { ?t a owl:Ontology }) ||
      (isBlank(?t) && not exists { ?x ?q ?t } )
    )
  # OWL vocabulary must not be pretty printed
    filter (! xt:system(?t))

  }
  order by ?t}
        
}

]]>
</body>
</rule>

<rule>
<body>
<![CDATA[
#
# Starting template for OWL pretty printing from RDF to Functional Syntax
# Olivier Corby - Wimmics Inria I3S - 2013-2015
#
template st:start {

  st:call-template(st:prefix)
  st:call-template(?start)
  
}
where {

  bind (
    if (exists { ?in a owl:Ontology }, st:ontology, st:body) 
  as ?start)  
      
}

]]>
</body>
</rule>

<rule>
<body>
<![CDATA[
#
# Starting template for OWL pretty printing from RDF to Functional Syntax
# Olivier Corby - Wimmics Inria I3S - 2013
#
template st:html {
  st:call-template-with(st:server, st:head)
  
  "<h3>OWL Functional Syntax</h3>"
  "<pre>"
  st:call-template(st:start)
  "</pre>"
  
  st:call-template-with(st:server, st:tail)
}
where {
     bind(st:export(st:html, true) as ?ctx) 
}

]]>
</body>
</rule>

<rule>
<body>
<![CDATA[
#
# Starting template for OWL pretty printing from RDF to Functional Syntax
# Olivier Corby - Wimmics Inria I3S - 2013
#
template st:import {

   "Import(" ?i  ")\n"
   ; separator = ""
   
}
where {

  ?in a owl:Ontology ; 
    owl:imports ?i 
      
}

]]>
</body>
</rule>

<rule>
<body>
<![CDATA[
template st:annotation(?in) {

   st:call-template(st:annotation1, ?in)
   st:call-template(st:annotation2, ?in)
   
}
where {
  
}
]]>
</body>
</rule>

<rule>
<body>
<![CDATA[
template  st:class  {

  xt:nl(st:apply-templates-with-all(st:owlclass, ?t), 2)
  ; separator = ""
}
where {

  {select distinct ?t where {
    values ?p { rdf:type  owl:disjointWith owl:equivalentClass  rdfs:subClassOf owl:hasKey owl:disjointUnionOf}
     ?t ?p ?y 
    filter (
      (isURI(?t)   && not exists { ?t a owl:Ontology }) ||
      (isBlank(?t) && not exists { ?x ?q ?t } )
    )
  # OWL vocabulary must not be pretty printed
      filter (! xt:system(?t))
        
  }
  order by ?t}
        
}

]]>
</body>
</rule>

<rule>
<body>
<![CDATA[
#
# Starting template for OWL pretty printing from RDF to Functional Syntax
# st:apply-all-templates run all templates on each value 
# Olivier Corby - Wimmics Inria I3S - 2013
#

template  st:declare  {

  xt:nl(st:apply-templates-with-all(st:owldecl, ?t), 1)
  ; separator = ""
  
    
}
where {

  {select distinct ?t where {
     ?t rdf:type|owl:equivalentClass ?y 
    filter (isURI(?t))
    
    # OWL vocabulary must not be pretty printed
    filter (! xt:system(?t))       
    filter not exists { ?t a owl:Ontology }
        
  }
  order by ?t}
}

]]>
</body>
</rule>

<rule>
<body>
<![CDATA[
template st:annotation1 {
   "Annotation(" 
      ?p " " ?t
   ")\n"
   ; separator = ""
}
where {
  ?in ?p ?t
  filter not exists {
   ?a a owl:Annotation ;
      owl:annotatedSource   ?in ;
      owl:annotatedProperty ?p ;     
      owl:annotatedTarget   ?t 
  }
}
values ?p { 
  owl:priorVersion owl:backwardCompatibleWith owl:incompatibleWith 
  rdfs:comment rdfs:label rdfs:seeAlso rdfs:isDefinedBy 
}
]]>
</body>
</rule>

<rule>
<body>
<![CDATA[

template  st:property  {

    xt:nl(st:apply-templates-with-all(st:owlproperty, ?t), 2)
    ; separator = ""
   
}
where {

  {select distinct ?t where {
  values ?p { rdf:type owl:propertyChainAxiom owl:propertyDisjointWith owl:inverseOf rdfs:domain rdfs:range rdfs:subPropertyOf owl:equivalentProperty}
     ?t ?p ?y 
    filter (
      (isURI(?t)   && not exists { ?t a owl:Ontology }) ||
      (isBlank(?t) && not exists { ?x ?q ?t } )
    )
  # OWL vocabulary must not be pretty printed
    filter (! xt:system(?t))

        
  }
  order by ?t}
        
}

]]>
</body>
</rule>

<rule>
<body>
<![CDATA[
#
# defaut processing of a variable is 
# st:turtle on URI 
# st:apply-templates on Blank and Literal
# Literals are displayed by st:xsdLiteral  (literalvalue.rq)
# otherwise must use st:turtle explicitely (e.g. cardinality.rq)
#
# Olivier Corby, Wimmics Inria I3S, 2014
#
template st:profile(?in) {

    define (st:process(?in) =  
      if (isURI(?in), st:protect(?in),	
	st:apply-templates(?in))
    ) 
  
 define (st:protect(?in) =
    let (?t = st:turtle(?in),
      if (st:get(st:html, true), 
	    xt:protect(?t), 
	    ?t))
  )
  
   define (xt:protect(?s) =
        replace(replace(?s, "&", "&amp;"), "<", "&lt;")
    )
  
  define (xt:turtle(?t) = 
    st:apply-templates-with(st:turtle, ?t)
  )
  
  define (xt:nl(?x, ?n) =
    if (?x = "", ?x, 
      concat(?x, if (?n = 1, "\n", "\n\n")))
  )
  
  define (xt:system(?t) =
          (strstarts(?t, owl:) 
       ||  strstarts(?t, rdf:) 
       ||  strstarts(?t, rdfs:)
       ||  strstarts(?t, xsd:))
  )
  
}
where {
}
]]>
</body>
</rule>

<rule>
<body>
<![CDATA[
template  st:body  {

  st:call-template(st:declare)  st:nl()
  st:call-template(st:class)    st:nl()
  st:call-template(st:property) st:nl()
  st:call-template(st:statement)
  
}
where {

 
        
}

]]>
</body>
</rule>

<rule>
<body>
<![CDATA[
template st:annotation2 {     
   "Annotation(\n" 
   
      group { "Annotation(" ?q  " "  ?c ")\n" }
      
      ?p " " ?t 
   
   ")\n"
}
where {
  ?a owl:annotatedSource ?in ;
      a owl:Annotation ;
      owl:annotatedProperty ?p ;      
      owl:annotatedTarget   ?t ;
      ?q ?c
      
      filter(?q not in (rdf:type, owl:annotatedSource, owl:annotatedProperty, owl:annotatedTarget))
      
  ?in ?p ?t
    
}



]]>
</body>
</rule>

<rule>
<body>
<![CDATA[
template st:header {
"""#
# Generated using OWL 2 to Functional Syntax STTL Transformation
# Olivier Corby - Wimmics - Inria, I3S, UNS, CNRS
# """ now() 

"""
#
"""
}
where {
}
]]>
</body>
</rule>

<rule>
<body>
<![CDATA[
#
# Starting template for OWL pretty printing from RDF to Functional Syntax
# Olivier Corby - Wimmics Inria I3S - 2013
#
template st:ontology {

  "Ontology(" 
  if (isURI(?in), ?in, "") 
  " " ?uri "\n"

    st:call-template(st:import, ?in)
    st:call-template(st:annotation, ?in)
    "\n"
    st:call-template(st:body)
    
  "\n)\n"
}
where {

  ?in a owl:Ontology   
  optional { ?in owl:versionIRI ?uri }
      
}

]]>
</body>
</rule>

<rule>
<body>
<![CDATA[
template st:prefix {
  "Prefix(" str(?p) ": = <" str(?n) ">)" "\n"
}
where {
  bind (kg:unnest(st:prefix()) as (?p, ?n))
}
]]>
</body>
</rule>

</rdf:RDF>
