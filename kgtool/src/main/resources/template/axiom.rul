<?xml version='1.0' encoding='UTF-8'?>
<!--
SPARQL Template Transformation
Olivier Corby - Wimmics - Inria UNS CNRS I3S
Thu Sep 24 10:20:19 CEST 2015
-->
<rdf:RDF  xmlns:rdf='http://www.w3.org/1999/02/22-rdf-syntax-ns#' 
  xmlns='http://ns.inria.fr/edelweiss/2011/rule#'>
<rule>
<body>
<![CDATA[
template st:profile {

  st:define (st:aggregate(?x) = st:agg_and(?x))

}
where {
}

]]>
</body>
</rule>

<rule>
<body>
<![CDATA[

template  {
  ?suc  
}
where {
  ?in owl:AllDisjointClasses ?z
  
   bind (
    not exists { 
      ?z rdf:rest*/rdf:first ?e      
      filter(! st:call-template-with(st:subexp, st:subClassExpression, ?e))
    }
    as ?suc
  )
  
  filter(st:visit(st:disjointClass, ?in, ?suc))

}



]]>
</body>
</rule>

<rule>
<body>
<![CDATA[
template {
  ?suc  
}
where {

  ?in rdfs:subClassOf ?y
  
  bind (
    ( isURI(?in) || not exists { ?x ?p ?in } ) &&
    st:call-template-with(st:subexp,   st:subClassExpression, ?in) &&
    st:call-template-with(st:superexp, st:superClassExpression, ?y)  
  as ?suc)
  
  filter(st:visit(st:subClass, ?in, ?suc))

        
}



]]>
</body>
</rule>

<rule>
<body>
<![CDATA[

template  {
  ?suc
}
where {
  ?in owl:equivalentClass ?y
  
  filter (
    isURI(?in) ||
    not exists { ?x ?p ?in }
  )
 
  bind (
    st:call-template-with(st:equivexp, st:equivClassExpression, ?in) &&
    st:call-template-with(st:equivexp, st:equivClassExpression, ?y)  
  as ?suc)
  
  filter(st:visit(st:equivClass, ?in, ?suc))

}



]]>
</body>
</rule>

<rule>
<body>
<![CDATA[

template  {
  ?suc 
}
where {
  ?in owl:disjointWith ?y
  
  filter (
    isURI(?in) ||
    not exists { ?x ?p ?in }
  )
   
  bind (
    st:call-template-with(st:subexp, st:subClassExpression, ?in) && 
    st:call-template-with(st:subexp, st:subClassExpression, ?y)  
  as ?suc)
  
  filter(st:visit(st:disjointClass, ?in, ?suc))


}



]]>
</body>
</rule>

<rule>
<body>
<![CDATA[
#
# Forbidden in OWL RL
#
template {
  false
}
where {

  { ?in owl:disjointUnionOf ?y }
  union { ?in a owl:ReflexiveProperty }
  
  filter(st:visit(st:fail, ?in, false))
 
}



]]>
</body>
</rule>

<rule>
<body>
<![CDATA[
# the following datatypes must not be used in OWL 2 RL:
# owl:real, owl:rational

template {
  ?suc
}
where {
  
  bind ( 
    not exists { 
      ?in ?p ?y 
      filter (datatype(?y) IN (owl:real, owl:rational))
    }
  as ?suc)

  filter (st:visit(st:datatypelit, st:datatype, ?suc))
}

]]>
</body>
</rule>

<rule>
<body>
<![CDATA[
  # OWL 2 RL does not support the predefined properties :
  # owl:topObjectProperty, owl:bottomObjectProperty,
  # owl:topDataProperty, and owl:bottomDataProperty

template {

  ?suc
}
where {

  bind ( not exists { {?x ?p ?y} union {?y ?p ?x} union { ?a ?x ?b } } as ?suc)
  
  filter(st:visit(st:properties, ?x, ?suc))
}
values ?x { 
  owl:topObjectProperty owl:bottomObjectProperty 
  owl:topDataProperty   owl:bottomDataProperty 
}

]]>
</body>
</rule>

<rule>
<body>
<![CDATA[

template  {
  ?suc  
}
where {
  ?in rdfs:domain|rdfs:range ?y
      
  bind (
    isURI(?y) ||
    st:call-template-with(st:superexp, st:superClassExpression, ?y)  
  as ?suc)
  
  filter(st:visit(st:domain, ?in, ?suc))

    
}



]]>
</body>
</rule>

<rule>
<body>
<![CDATA[

template  {
  ?suc  
}
where {
  ?in owl:hasKey ?z
  
   bind (
     st:call-template-with(st:subexp, st:subClassExpression, ?in)
   as ?suc)
   
   filter(st:visit(st:key, ?in, ?suc))
 
    
}



]]>
</body>
</rule>

<rule>
<body>
<![CDATA[

template {
  ?suc  
}
where {
  ?in a owl:NamedIndividual, ?t
  
  filter (
    isURI(?in) ||
    not exists { ?x ?p ?in }
  )
 
 bind (isURI(?t) ||
   st:call-template-with(st:superexp, st:superClassExpression, ?t) 
 as ?suc)
 
 filter(st:visit(st:individual, ?in, ?suc))

      
}



]]>
</body>
</rule>

</rdf:RDF>
