<?xml version='1.0' encoding='UTF-8'?>
<!--
SPARQL Template Transformation
Olivier Corby - Wimmics - Inria UNS CNRS I3S
Mon May 30 08:39:58 CEST 2016
-->
<rdf:RDF  xmlns:rdf='http://www.w3.org/1999/02/22-rdf-syntax-ns#' 
  xmlns='http://ns.inria.fr/edelweiss/2011/rule#'>
<rule>
<body>
<![CDATA[
template st:default2 (?sh, ?shape, ?s, ?vis){
    false
}
where {
    graph ?shape {
        bind (kg:display(st:atw(st:turtle, ?sh), ?s)    as ?r)
    }
}

]]>
</body>
</rule>

<rule>
<body>
<![CDATA[
prefix sh: <http://www.w3.org/ns/shacl#> 

template st:profile {}
where {}

function st:aggregate(?x) {
  st:agg_and(?x)
}











]]>
</body>
</rule>

<rule>
<body>
<![CDATA[
prefix sh: <http://www.w3.org/ns/shacl#> 

template (?shape, ?sh, ?vis, ?s){
  sh:safe(?shape, ?sh, ?suc)
}
where {

  graph ?shape {
    ?sh sh:class ?c ; sh:predicate ?p
  }
  
  ?s ?p ?o
  bind (exists { ?o rdf:type/rdfs:subClassOf* ?c } as ?suc)

  bind (st:report(sh:class, ?sh, ?shape, ?s, ?s, ?p, ?o, ?suc, ?vis) as ?b)
}


]]>
</body>
</rule>

<rule>
<body>
<![CDATA[
prefix sh: <http://www.w3.org/ns/shacl#> 

template (?shape, ?sh, ?vis, ?s){
  sh:safe(?shape, ?sh, ?suc)
}
where {

  graph ?shape {
    ?sh sh:equals ?q ; sh:predicate ?p
  }
  
  ?s ?p ?o  bind ( exists { ?s ?q ?o }   as ?suc)  
    
  bind (st:report(sh:equals, ?sh, ?shape, ?s, ?s, ?p, ?o, ?suc, ?vis) as ?b)
  
}

]]>
</body>
</rule>

<rule>
<body>
<![CDATA[
prefix sh: <http://www.w3.org/ns/shacl#> 

template (?shape, ?sh, ?vis, ?s){
  sh:safe(?shape, ?sh, ?suc)
}
where {

  graph ?shape {  
    ?sh sh:hasValue ?v ; sh:predicate ?p 
  }
  
  ?s ?p ?o
  bind (coalesce(?o = ?v, false) as ?suc)
  
  bind (st:report(sh:hasValue, ?sh, ?shape, ?s, ?s, ?p, st:null, ?suc, ?vis) as ?b)
}

]]>
</body>
</rule>

<rule>
<body>
<![CDATA[
prefix sh: <http://www.w3.org/ns/shacl#> 

template (?shape, ?sh, ?vis, ?s){
  sh:safe(?shape, ?sh, ?suc)
}
where {

  graph ?shape {
    ?sh sh:classIn ?lc ; sh:predicate ?p                     
  }
  
  ?s ?p ?o
  bind (
    exists { graph ?shape { ?lc rdf:rest*/rdf:first ?c } 
        ?o rdf:type/rdfs:subClassOf* ?c }    
  as ?suc)
  
  bind (st:report(sh:classIn, ?sh, ?shape, ?s, ?s, ?p, ?o, ?suc, ?vis) as ?b)
}

]]>
</body>
</rule>

<rule>
<body>
<![CDATA[
prefix sh: <http://www.w3.org/ns/shacl#> 

template (?shape, ?sh, ?vis, ?s){
  sh:safe(?shape, ?sh, ?suc)
}
where {

  graph ?shape {
    ?sh sh:disjoint ?q ; sh:predicate ?p  
  }
  
  ?s ?p ?o 
  bind (not exists { ?s ?q ?o } as ?suc)
    
  bind (st:report(sh:disjoint, ?sh, ?shape, ?s, ?s, ?p, ?o, ?suc, ?vis) as ?b)
  
}

]]>
</body>
</rule>

<rule>
<body>
<![CDATA[
prefix sh: <http://www.w3.org/ns/shacl#> 

template (?shape, ?sh, ?vis, ?s) {
  sh:safe(?shape, ?sh, ?suc)
}
where {
  graph ?shape {  
    ?sh sh:pattern ?exp ; sh:predicate ?p  
    optional { ?sh sh:flags ?flag }
  }
  ?s ?p ?o
  bind ( 
    coalesce(
        ! isBlank(?o) && 
        if (bound (?flag), regex(?o, ?exp, ?flag), regex(?o, ?exp)), 
        false) 
  as ?suc )

  bind (st:report(sh:pattern, ?sh, ?shape, ?s, ?s, ?p, ?o, ?suc, ?vis) as ?b)
}


]]>
</body>
</rule>

<rule>
<body>
<![CDATA[
prefix sh: <http://www.w3.org/ns/shacl#> 

template (?shape, ?sh, ?vis, ?s){
  sh:safe(?shape, ?sh, ?suc)
}
where {

  graph ?shape {
    ?sh sh:datatype ?d ; sh:predicate ?p 
  }
  
  ?s ?p ?o
  bind (isLiteral(?o) && datatype(?o) = ?d  as ?suc)
  
  bind (st:report(sh:datatype, ?sh, ?shape, ?s, ?s, ?p, ?o, ?suc, ?vis) as ?b)
}

]]>
</body>
</rule>

<rule>
<body>
<![CDATA[
prefix sh: <http://www.w3.org/ns/shacl#> 

template (?shape, ?sh, ?vis, ?s){
  sh:safe(?shape, ?sh, ?suc)
}
where {

  graph ?shape {
    ?sh sh:nodeKind ?k ; sh:predicate ?p 
  }
  
  ?s ?p ?o
  bind (sh:hasKind(?o, ?k)  as ?suc)

  bind (st:report(sh:nodeKind, ?sh, ?shape, ?s, ?s, ?p, ?o, ?suc, ?vis) as ?b)
}


]]>
</body>
</rule>

<rule>
<body>
<![CDATA[
prefix sh: <http://www.w3.org/ns/shacl#> 

template (?shape, ?sh, ?vis, ?s) {
  sh:safe(?sh, ?suc)
}
where {
  graph ?shape {  
    ?sh sh:minLength|sh:maxLength ?m ; ?q ?m ; sh:predicate ?p                      
  }
  ?s ?p ?o
  bind ( 
    coalesce(
        ! isBlank(?o) && 
        if (?q = sh:minLength, strlen(?o) >= ?m, strlen(?o) <= ?m), 
        false) 
  as ?suc )

  bind (st:report(?q, ?sh, ?shape, ?s, ?s, ?p, ?o, ?suc, ?vis) as ?b)
}


]]>
</body>
</rule>

<rule>
<body>
<![CDATA[
prefix sh: <http://www.w3.org/ns/shacl#> 

template (?shape, ?sh, ?vis, ?s){
  sh:safe(?shape, ?sh, ?suc)
}
where {

  graph ?shape {  
    ?sh sh:shape ?cst ; sh:predicate ?p 
  }
  
  ?s ?p ?o
  
  bind (sh:testShape(?shape, ?cst, ?o) as ?suc)
  
  bind (st:report(sh:valueShape, ?sh, ?shape, ?s, ?s, ?p, ?o, ?suc, ?vis) as ?b)
}

]]>
</body>
</rule>

<rule>
<body>
<![CDATA[
prefix sh: <http://www.w3.org/ns/shacl#> 

template (?shape, ?sh, ?vis, ?s){
  sh:safe(?shape, ?sh, ?suc)
}
where {

  graph ?shape {
    ?sh sh:equals ?q ; sh:predicate ?p
  }
  
  ?s ?q ?o  bind ( exists { ?s ?p ?o }   as ?suc)  
    
  bind (st:report(sh:equals, ?sh, ?shape, ?s, ?s, ?q, ?o, ?suc, ?vis) as ?b)
  
}

]]>
</body>
</rule>

<rule>
<body>
<![CDATA[
prefix sh: <http://www.w3.org/ns/shacl#> 

template (?shape, ?sh, ?vis, ?s){
  sh:safe(?shape, ?sh, ?suc)
}
where {

  graph ?shape {
    ?sh sh:lessThan|sh:lessThanOrEquals ?q ; ?r ?q ; sh:predicate ?p 
  }
  
  ?s ?p ?o ; ?q ?v
  
  bind (coalesce(if (?r = sh:lessThan, ?o < ?v, ?o <= ?v), false) as ?suc)
    
  bind (st:report(?r, ?sh, ?shape, ?s, ?s, ?q, ?o, ?suc, ?vis) as ?b)
  
}
 

]]>
</body>
</rule>

<rule>
<body>
<![CDATA[
prefix sh: <http://www.w3.org/ns/shacl#> 

template (?shape, ?sh, ?vis, ?s){
  sh:safe(?shape, ?sh, ?suc)
}
where {

  graph ?shape {  
    ?sh sh:minCount|sh:maxCount ?m ; ?q ?m ; sh:predicate ?p                      
  }

  bind (sh:count(?s, ?p) as ?c)  
  bind (if (?q = sh:minCount, ?c >= ?m, ?c <= ?m)    as ?suc)
  
  bind (st:report(?q, ?sh, ?shape, ?s, ?s, ?p, ?c, ?suc, ?vis) as ?b)
}


]]>
</body>
</rule>

<rule>
<body>
<![CDATA[
prefix sh: <http://www.w3.org/ns/shacl#> 

template (?shape, ?sh, ?vis, ?s) {
  sh:safe(?sh, ?suc)
}
where {
  graph ?shape {  
    ?sh sh:stem ?exp ; sh:predicate ?p  
  }
  ?s ?p ?o
  bind (isURI(?o) && strstarts(?o, ?exp)
  as ?suc )

  bind (st:report(sh:pattern, ?sh, ?shape, ?s, ?s, ?p, ?o, ?suc, ?vis) as ?b)
}


]]>
</body>
</rule>

<rule>
<body>
<![CDATA[
prefix sh: <http://www.w3.org/ns/shacl#> 

template (?shape, ?sh, ?vis, ?s){
  sh:safe(?shape, ?sh, ?suc)
}
where {

  graph ?shape {
    ?sh sh:datatypeIn ?lc ; sh:predicate ?p                     
  }
  
  ?s ?p ?o
  bind (
    isLiteral(?o) &&
    exists { 
        graph ?shape { ?lc rdf:rest*/rdf:first ?d } 
        filter (datatype(?o) = ?d) }    
  as ?suc)
  
  bind (st:report(sh:datatypeIn, ?sh,  ?shape, ?s, ?s, ?p, ?o, ?suc, ?vis) as ?b)
}

]]>
</body>
</rule>

<rule>
<body>
<![CDATA[
prefix sh: <http://www.w3.org/ns/shacl#> 

template (?shape, ?sh, ?vis, ?s){
  sh:safe(?shape, ?sh, ?suc)
}
where {

  graph ?shape {
    ?sh sh:in ?lv ; sh:predicate ?p                     
  }
  
  ?s ?p ?o
  bind (
    exists { 
        graph ?shape { ?lv rdf:rest*/rdf:first ?v } 
        filter (?o = ?v && ( isURI(?o) || datatype(?o) = datatype(?v))) }    
  as ?suc)
  
  bind (st:report(sh:in, ?sh, ?shape, ?s, ?s, ?p, ?o, ?suc, ?vis) as ?b)
}

]]>
</body>
</rule>

<rule>
<body>
<![CDATA[
prefix sh: <http://www.w3.org/ns/shacl#> 

template (?shape, ?sh, ?vis, ?s) {
  sh:safe(?shape, ?sh, ?suc)
}
where {
  graph ?shape {  
    ?sh sh:minInclusive|sh:minExclusive|sh:maxInclusive|sh:maxExclusive ?m ; ?q ?m ; sh:predicate ?p                      
  }
  ?s ?p ?o
  bind ( 
    coalesce(
        if (?q = sh:minInclusive, ?o >= ?m,
        if (?q = sh:minExclusive, ?o > ?m,
        if (?q = sh:maxInclusive, ?o <= ?m, 
            ?o < ?m))), 
    false) 
  as ?suc )
  
  bind (st:report(?q, ?sh, ?shape, ?s, ?s, ?p, ?o, ?suc, ?vis) as ?b)
}


]]>
</body>
</rule>

<rule>
<body>
<![CDATA[
prefix sh: <http://www.w3.org/ns/shacl#> 

template (?shape, ?sh, ?vis, ?s){
  sh:safe(?shape, ?sh, ?suc)
}
where {

  graph ?shape {
    ?sh sh:uniqueLang ?l ; sh:predicate ?p 
  }
  
  ?s ?p ?o
  bind (lang(?o) as ?lang)
  filter (bound(?lang) && ?lang != "")
  
  bind (not exists { ?s ?p ?v  filter (?v != ?o && lang(?v) = ?lang) }    as ?suc)

  bind (st:report(sh:uniqueLang, ?sh, ?shape, ?s, ?s, ?p, ?o, ?suc, ?vis) as ?b)
}

]]>
</body>
</rule>

</rdf:RDF>
